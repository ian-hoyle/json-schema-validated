<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>json-schema-validated</title>
  <meta name="description" content="A Scala data validation library using JSON Schema and Cats Validated for functional error handling" />
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 1.25rem; line-height: 1.6; }
    .wrap { max-width: 1200px; margin: 0 auto; }
    header { display:flex; align-items:baseline; justify-content:space-between; gap:.5rem; margin-bottom:1.5rem; border-bottom: 1px solid #8884; padding-bottom: 1rem; }
    h1, h2, h3 { line-height: 1.2; }
    h1 { font-size: 2.2rem; margin: 0; color: #2563eb; }
    h2 { font-size: 1.5rem; margin-top: 2rem; margin-bottom: 1rem; color: #1e40af; border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; }
    h3 { font-size: 1.25rem; margin-top: 1.5rem; margin-bottom: 0.75rem; color: #1e40af; }
    p { line-height: 1.65; margin-bottom: 1rem; }
    .lead { font-size: 1.1rem; color: #4b5563; margin-bottom: 1.5rem; }
    .muted { opacity: .75; font-size: .95rem; }
    pre { background: #f8fafc; border: 1px solid #e2e8f0; padding: 1rem; border-radius: 8px; overflow: auto; margin: 1rem 0; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: .9em; background: #f1f5f9; padding: 0.2em 0.4em; border-radius: 3px; }
    pre code { background: none; padding: 0; }
    table { border-collapse: collapse; width: 100%; margin: 1rem 0; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    th, td { border: 1px solid #d1d5db; padding: .75rem; text-align: left; }
    th { background: #f9fafb; font-weight: 600; }
    nav a { margin-right: 1rem; text-decoration: none; color: #2563eb; font-weight: 500; }
    nav a:hover { color: #1d4ed8; text-decoration: underline; }
    .note { padding: 1rem; border-left: 4px solid #3b82f6; background: #eff6ff; border-radius: 6px; margin: 1rem 0; }
    .warning { padding: 1rem; border-left: 4px solid #f59e0b; background: #fffbeb; border-radius: 6px; margin: 1rem 0; }
    .success { padding: 1rem; border-left: 4px solid #10b981; background: #ecfdf5; border-radius: 6px; margin: 1rem 0; }
    ul, ol { margin: .5rem 0 1rem 1.5rem; }
    li { margin-bottom: 0.5rem; }
    hr { border: none; border-top: 2px solid #e5e7eb; margin: 2rem 0; }
    a { color: #2563eb; text-decoration: none; }
    a:hover { color: #1d4ed8; text-decoration: underline; }
    .badge { display: inline-block; padding: 0.25rem 0.75rem; background: #dbeafe; color: #1e40af; border-radius: 1rem; font-size: 0.875rem; font-weight: 500; margin-right: 0.5rem; }
    .feature-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; margin: 1.5rem 0; }
    .feature-card { padding: 1.5rem; border: 1px solid #e5e7eb; border-radius: 8px; background: #fafafa; }
    .feature-card h4 { margin: 0 0 0.5rem 0; color: #1e40af; }

    /* Images row for README visuals */
    .img-row { display:flex; gap:.75rem; align-items:stretch; margin: 2rem 0; }
    .img-cell { flex:1 1 0; height:200px; }
    .img-cell img { display:block; width:100%; height:100%; object-fit:cover; border-radius:8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
    .img-cell--contain img { object-fit:contain; background:transparent; }

    /* Quick start section */
    .quick-start { background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; }
    .quick-start h3 { margin-top: 0; color: #0c4a6e; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <div class="badge">Scala 3</div>
        <div class="badge">JSON Schema</div>
        <div class="badge">Cats Effect</div>
      </div>
      <nav class="muted">
        <a href="./readme.html">README</a>
        <a href="./schema-domain-map.html">Schema ‚Üî Domain Mapping</a>
        <a href="./metadata-template.html">Metadata Template</a>
      </nav>
    </header>

    <article id="content">
      <h1 id="json-schema-validated">json-schema-validated</h1>
      <p class="lead">A powerful Scala data validation library that combines JSON Schema validation with functional programming principles using <a href="https://typelevel.org/cats/datatypes/validated.html">Cats Validated</a> for robust error accumulation and composable validation pipelines.</p>

      <!-- Added visuals before Features -->
      <div class="img-row">
        <div class="img-cell">
          <img src="./img/fp.webp" alt="Functional Programming with JSON Schema" />
        </div>
        <div class="img-cell img-cell--contain">
          <img src="./img/cats.png" alt="Typelevel Cats - Functional Programming Library" />
        </div>
      </div>

      <div class="quick-start">
        <h3>üöÄ Quick Start</h3>
        <p>Get up and running in minutes:</p>
        <pre><code class="language-bash"># Prerequisites: Java 11+, SBT, Scala 3
sbt test                                    # Run tests
echo '{"closure_type":"Closed","file_path":null}' > sample.json
sbt "runMain examples.JsonValidationApp --schemas=organisationBase.json,closedRecord.json --json-file=sample.json"
sbt "runMain examples.CSVFileValidationApp" # Run CSV validation example</code></pre>
      </div>

      <h2 id="why-json-schema-validated">Why json-schema-validated?</h2>
      <div class="feature-grid">
        <div class="feature-card">
          <h4>üéØ Schema-Driven Validation</h4>
          <p>Define your data structure once using JSON Schema and validate across multiple domains and formats.</p>
        </div>
        <div class="feature-card">
          <h4>üîß Composable Validations</h4>
          <p>Build complex validation pipelines with fail-fast and parallel error-accumulating strategies.</p>
        </div>
        <div class="feature-card">
          <h4>üí¨ User-Friendly Errors</h4>
          <p>Automatic mapping to human-readable error messages using properties files for each schema.</p>
        </div>
        <div class="feature-card">
          <h4>üèóÔ∏è Functional Architecture</h4>
          <p>Leverages Cats Validated for type-safe error handling and functional composition patterns.</p>
        </div>
      </div>

      <h2 id="features">Key Features</h2>
      <ul>
        <li><strong>Multi-Schema Validation:</strong> Validate data against one or multiple JSON Schemas using NetworkNT JSON Schema Validator</li>
        <li><strong>Functional Composition:</strong> Compose validations as functions with fail-fast chains and parallel error-accumulating checks</li>
        <li><strong>Domain Mapping:</strong> Map between domain-specific headers and canonical property names via configuration</li>
        <li><strong>Smart Error Messages:</strong> User-friendly, per-schema error messages using .properties files</li>
        <li><strong>Conditional Validation:</strong> Support for complex business rules using JSON Schema if/then constructs</li>
        <li><strong>Code Generation:</strong> SBT task to automatically generate Scala case classes from schemas</li>
        <li><strong>Production Ready:</strong> Includes CSV validation examples and AWS Lambda-compatible handlers</li>
      </ul>

      <h2 id="toc">üìñ Table of Contents</h2>
      <ul>
        <li><a href="#use-case">Use Case: TNA Data Transfer</a></li>
        <li><a href="#how-it-works">How It Works</a></li>
        <li><a href="#validation-patterns">Validation Patterns</a></li>
        <li><a href="#architecture">Architecture Overview</a></li>
        <li><a href="#schema-structure">Schema Structure</a></li>
        <li><a href="#api-reference">API Reference</a></li>
        <li><a href="#configuration">Configuration</a></li>
        <li><a href="#examples">Examples</a></li>
        <li><a href="#additional-resources">Additional Resources</a></li>
      </ul>

      <h2 id="use-case">üéØ Use Case: TNA Data Transfer</h2>
      <p>Originally designed to support data transfer to The National Archives (TNA), this library addresses common enterprise validation challenges:</p>

      <div class="success">
        <strong>‚úÖ What We Solve:</strong>
        <ul>
          <li>Multi-format data validation (CSV, JSON, XML)</li>
          <li>Centralized schema definition with domain-specific mappings</li>
          <li>Composable validation rules for complex business logic</li>
          <li>User-friendly error reporting for non-technical users</li>
          <li>Automated documentation generation from schemas</li>
        </ul>
      </div>

      <h3 id="real-world-example">Real-World Example</h3>
      <p><strong>Input:</strong> CSV file with metadata for digital archives</p>
      <table>
        <thead>
          <tr>
            <th>Filepath</th>
            <th>Filename</th>
            <th>Date last modified</th>
            <th>Closure status</th>
            <th>Description</th>
            <th>Language</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>test/test1.txt</td>
            <td>test1.txt</td>
            <td>2024-03-26</td>
            <td>Closed</td>
            <td>Archive document</td>
            <td>English</td>
          </tr>
          <tr>
            <td>test/test2.txt</td>
            <td>test2.txt</td>
            <td>2024-03-26</td>
            <td>OpenX</td>
            <td>Invalid status example</td>
            <td>English</td>
          </tr>
        </tbody>
      </table>

      <p><strong>Output:</strong> Structured validation results with actionable error messages</p>
      <pre><code class="language-json">[
  {
    "assetId": "test/test2.txt",
    "errors": [
      {
        "validationProcess": "organisationBase.json",
        "property": "Closure status",
        "errorKey": "enum",
        "message": "Must be either 'Open' or 'Closed'",
        "value": "OpenX"
      }
    ]
  }
]</code></pre>

      <h2 id="how-it-works">‚öôÔ∏è How It Works</h2>
      <ol>
        <li><strong>Data Loading:</strong> Parse input data (CSV, JSON, etc.) into structured <code>List[Data]</code></li>
        <li><strong>Fail-Fast Validation:</strong> Apply sequential validations (header mapping, data enrichment) that stop on first failure</li>
        <li><strong>Parallel Validation:</strong> Run independent schema validations concurrently and accumulate all errors</li>
        <li><strong>Error Transformation:</strong> Map technical validation errors to user-friendly messages using schema properties</li>
        <li><strong>Result Aggregation:</strong> Return either validated data or comprehensive error report grouped by asset</li>
      </ol>

      <h2 id="validation-patterns">üîÑ Validation Patterns</h2>

      <div class="note">
        <strong>üí° Key Concept:</strong> Each validation is a function <code>List[Data] ‚Üí ValidatedNel[ValidationErrors, List[Data]]</code>
      </div>

      <h3 id="validation-as-composable">Composable Validation Functions</h3>
      <p>Organize validations into two complementary pipelines:</p>
      <ul>
        <li><strong>Fail-Fast Pipeline:</strong> Sequential execution using <code>andThen</code> - stops at first error</li>
        <li><strong>Parallel Pipeline:</strong> Concurrent execution with error accumulation using <code>ValidatedNel</code></li>
      </ul>

      <pre><code class="language-scala">import cats.data.ValidatedNel
import cats.syntax.all._
import cats.effect.IO
import cats.effect.unsafe.implicits.global
import validation.error.CSVValidationResult.dataValidationResultMonoid

// Core type definitions
type DataValidation = ValidatedNel[ValidationErrors, List[Data]]

// Fail-fast validation pipeline
def runFailFast(
  loadedData: DataValidation,
  steps: Seq[List[Data] => DataValidation]
): DataValidation =
  steps.foldLeft(loadedData)((acc, f) => acc.andThen(f))

// Parallel validation with error accumulation
def runComposed(
  data: List[Data],
  steps: Seq[List[Data] => DataValidation]
): DataValidation =
  steps.map(f => IO(f(data))).parSequence.map(_.combineAll).unsafeRunSync()

// Combined validation strategy
val result: DataValidation =
  runFailFast(loadedData, failFastValidations)
    .andThen(ds => runComposed(ds, composeValidations))
</code></pre>

      <div class="warning">
        <strong>‚ö†Ô∏è Architecture Note:</strong> Error-to-message mapping happens within each schema validation using the schema's <code>.properties</code> file. The Monoid simply combines these pre-processed, user-friendly errors.
      </div>

      <h2 id="architecture">üèóÔ∏è Architecture Overview</h2>
      <pre><code>                    üìÅ Data Sources
                    (CSV, JSON, XML)
                           ‚îÇ
                           ‚ñº
                    üîÑ Data Loader
                  (Parse ‚Üí List[Data])
                           ‚îÇ
                           ‚ñº
              ‚ö° Fail-Fast Validations (andThen)
              ‚Ä¢ Header mapping
              ‚Ä¢ Data enrichment
              ‚Ä¢ Required field checks
                           ‚îÇ
                           ‚ñº
              üîÄ Parallel Validations (combineAll)
              ‚Ä¢ JSON Schema validation
              ‚Ä¢ Business rules
              ‚Ä¢ Cross-field validation
              ‚Ä¢ Error ‚Üí User message mapping
                           ‚îÇ
                           ‚ñº
                    ‚úÖ Validated Result
                  (Success | Error Report)
</code></pre>

      <h2 id="schema-structure">üìã Schema Structure</h2>
      <p>The validation system uses a layered schema approach:</p>

      <h3 id="base-schema">1. Base Data Schema</h3>
      <p>Defines core data types and constraints:</p>
      <pre><code class="language-json">{
  "$id": "/schema/baseSchema",
  "type": "object",
  "properties": {
    "foi_exemption_code": {
      "type": ["array", "null"],
      "items": {
        "type": "string",
        "$ref": "classpath:/definitions.json#/definitions/foi_codes"
      }
    },
    "file_size": {
      "type": "integer",
      "minimum": 1,
      "description": "File size in bytes"
    },
    "file_path": {
      "type": "string",
      "minLength": 1,
      "pattern": "^[^\\0]+$"
    }
  }
}</code></pre>

      <h3 id="conditional-schema">2. Conditional Validation Schema</h3>
      <p>Applies context-sensitive business rules:</p>
      <pre><code class="language-json">{
  "$id": "/schema/closed-record",
  "type": "object",
  "allOf": [
    {
      "if": {
        "properties": {
          "closure_type": { "const": "Closed" }
        },
        "required": ["closure_type"]
      },
      "then": {
        "required": ["closure_start_date", "closure_period"],
        "properties": {
          "closure_start_date": { "type": "string", "format": "date" },
          "closure_period": { "type": "integer", "minimum": 1 },
          "foi_exemption_code": { "type": "array", "minItems": 1 }
        }
      },
      "else": {
        "properties": {
          "closure_start_date": { "type": "null" },
          "closure_period": { "type": "null" }
        }
      }
    }
  ]
}</code></pre>

      <h3 id="domain-mapping">3. Domain Mapping Configuration</h3>
      <p>Maps between canonical properties and domain-specific headers:</p>
      <pre><code class="language-json">{
  "$id": "/schema/config",
  "type": "object",
  "configItems": [
    {
      "key": "file_path",
      "domainKeys": [
        { "domain": "TDRMetadataUpload", "domainKey": "Filepath" },
        { "domain": "TDRDataLoad", "domainKey": "File Location" }
      ]
    },
    {
      "key": "foi_exemption_code",
      "domainKeys": [
        { "domain": "TDRMetadataUpload", "domainKey": "FOI exemption code" }
      ]
    }
  ]
}</code></pre>

      <h2 id="api-reference">üìö API Reference</h2>

      <h3 id="core-validation">Core Validation Function</h3>
      <pre><code class="language-scala">def validate(
  dataLoader: DataValidation,
  failFastValidations: Seq[List[Data] => DataValidation],
  composeValidations: Seq[List[Data] => DataValidation]
): DataValidation</code></pre>

      <h3 id="key-types">Key Data Types</h3>
      <ul>
        <li><strong>Data:</strong> Single validation record containing <code>row_number</code>, <code>assetId</code>, <code>data</code> map, and <code>json</code> representation</li>
        <li><strong>ValidationErrors:</strong> Asset-specific errors with <code>assetId</code> and <code>Set[JsonSchemaValidationError]</code></li>
        <li><strong>JsonSchemaValidationError:</strong> Detailed error info including <code>validationProcess</code>, <code>property</code>, <code>errorKey</code>, <code>message</code>, and <code>value</code></li>
      </ul>

      <div class="note">
        <strong>üí° Type Safety:</strong> <code>DataValidation</code> is a type alias for <code>ValidatedNel[ValidationErrors, List[Data]]</code>, providing compile-time guarantees for error handling.
      </div>

      <h2 id="error-messages">üí¨ User-Friendly Error Messages</h2>
      <p>Each JSON schema has a corresponding <code>.properties</code> file defining human-readable error messages:</p>

      <div class="feature-grid">
        <div class="feature-card">
          <h4>Schema: organisationBase.json</h4>
          <p><strong>Properties:</strong> organisationBase.properties</p>
          <pre><code># Format: {property}.{errorKey}={message}
closure_type.enum=Must be either 'Open' or 'Closed'
file_size.minimum=File size must be at least 1 byte
file_path.minLength=File path cannot be empty</code></pre>
        </div>
      </div>

      <h2 id="configuration">‚öôÔ∏è Configuration Setup</h2>
      <pre><code class="language-scala">def prepareValidationConfiguration(
      configFile: String,
      baseSchema: String
  ): ValidatorConfiguration = {

    val csvConfigurationReader = for {
      altHeaderToPropertyMapper <- Reader(domainPropertyToBasePropertyMapper)
      propertyToAltHeaderMapper <- Reader(domainBasePropertyToPropertyMapper)
      valueMapper               <- Reader(stringValueMapper)
    } yield ValidatorConfiguration(
      altHeaderToPropertyMapper,
      propertyToAltHeaderMapper,
      valueMapper
    )
    csvConfigurationReader.run(
      ConfigParameters(configFile, baseSchema, decodeConfig(configFile))
    )
  }
  case class ValidatorConfiguration(
    domainKeyToProperty: String => String => String,
    propertyToDomainKey: String => String => String,
    valueMapper: (String, String) => Any
    )</code></pre>

      <h2 id="examples">üöÄ Examples</h2>

      <h3 id="basic-usage">Basic Usage Pattern</h3>
      <pre><code class="language-scala">import validation.Validation.validate
import validation.{DataValidation, Data, ValidationErrors}

// Load your data
val dataLoader: DataValidation = loadCsvFile("data.csv")

// Define validation pipelines
val failFastValidations: Seq[List[Data] => DataValidation] = Seq(
  validateHeaders,      // Ensure required headers exist
  mapDomainKeys,       // Map domain-specific keys to canonical names
  enrichWithJson       // Convert data to JSON for schema validation
)

val composeValidations: Seq[List[Data] => DataValidation] = Seq(
  validateAgainstBaseSchema,     // Apply base data validation
  validateBusinessRules,         // Apply conditional business logic
  validateCrossFieldConstraints  // Check relationships between fields
)

// Execute validation
val result = validate(dataLoader, failFastValidations, composeValidations)

// Handle results
result match {
  case Valid(data) =>
    println(s"‚úÖ Validation successful! Processed ${data.length} records")
  case Invalid(errors) =>
    println(s"‚ùå Validation failed with ${errors.length} error groups")
    errors.foreach(printErrorReport)
}</code></pre>

      <div class="quick-start">
        <h3>üéÆ Try It Now</h3>
        <pre><code class="language-bash"># Clone and run examples
git clone https://github.com/ian-hoyle/json-schema-validated.git
cd json-schema-validated

# Run comprehensive test suite
sbt test

# Generate case classes from schemas
sbt generateCaseClasses

# Run CSV validation example
sbt "runMain examples.CSVFileValidationApp"

# AWS Lambda handler example
sbt "runMain examples.CSVFileValidationLambdaHandler"</code></pre>
      </div>

      <h2 id="additional-resources">üìã Additional Resources</h2>
      <div class="feature-grid">
        <div class="feature-card">
          <h4>üó∫Ô∏è Schema Domain Mapping</h4>
          <p>Interactive visualization of property mappings across domains</p>
          <a href="./schema-domain-map.html">View Mapping Tool ‚Üí</a>
        </div>
        <div class="feature-card">
          <h4>üìã Metadata Template</h4>
          <p>TNA metadata template rendered as user-friendly reference table</p>
          <a href="./metadata-template.html">View Template ‚Üí</a>
        </div>
      </div>

      <hr>

      <div class="note">
        <strong>üîó External Dependencies:</strong>
        <ul>
          <li><a href="https://github.com/networknt/json-schema-validator">NetworkNT JSON Schema Validator</a> - JSON Schema validation engine</li>
          <li><a href="https://typelevel.org/cats/datatypes/validated.html">Cats Validated</a> - Functional error accumulation</li>
          <li><a href="https://typelevel.org/cats-effect/">Cats Effect</a> - Functional concurrency and resource management</li>
        </ul>
      </div>
    </article>
  </div>
</body>
</html>
