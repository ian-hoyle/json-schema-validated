import sbt._
import Keys._
import scala.io.Source
import scala.util.Using

/** Auto plugin to generate constants for each distinct domain value found in config.json (configItems[].domainKeys[].domain).
  * Produces a Scala object with one constant per domain.
  */
object DomainKeysGeneratorPlugin extends AutoPlugin {
  object autoImport {
    val generateConfigDomainsConstants = taskKey[Seq[File]]("Generate constants for domain entries in config.json")
    val configJsonFile                 = settingKey[File]("Path to config.json containing configItems")
    val configDomainsObjectPackage     = settingKey[String]("Package name for generated domains object")
    val configDomainsObjectName        = settingKey[String]("Object name for generated domains constants")
  }
  import autoImport._

  override def trigger: PluginTrigger = allRequirements

  override def projectSettings: Seq[Setting[_]] = Seq(
    configJsonFile             := (Compile / resourceDirectory).value / "config.json",
    configDomainsObjectPackage := "validation.generated",
    configDomainsObjectName    := "ConfigDomains",
    Compile / sourceGenerators += generateConfigDomainsConstants.taskValue,
    generateConfigDomainsConstants := {
      val log        = streams.value.log
      val file       = configJsonFile.value
      val outDir     = (Compile / sourceManaged).value / "generated"
      val objectName = configDomainsObjectName.value
      val pkg        = configDomainsObjectPackage.value

      if (!file.exists()) {
        log.warn("[DomainKeysGenerator] config.json not found: " + file)
        Seq.empty
      } else {
        log.info("[DomainKeysGenerator] Parsing: " + file.getName)
        import ujson._
        val jsonStr = Using(Source.fromFile(file)(scala.io.Codec.UTF8))(_.mkString).get
        val parsed  = ujson.read(jsonStr)

        val domains: Seq[String] = parsed.obj.get("configItems") match {
          case Some(arr: ujson.Arr) =>
            arr.value.flatMap { item =>
              item.obj.get("domainKeys") match {
                case Some(dks: ujson.Arr) =>
                  dks.value.flatMap { dk =>
                    dk.obj.get("domain") match {
                      case Some(ujson.Str(s)) if s.trim.nonEmpty => Some(s.trim)
                      case _ => None
                    }
                  }
                case _ => Nil
              }
            }.distinct.sorted
          case _ =>
            log.warn("[DomainKeysGenerator] No configItems array found in config.json")
            Seq.empty
        }

        if (domains.isEmpty) {
          log.warn("[DomainKeysGenerator] No domains discovered. Skipping generation.")
          Seq.empty
        } else {
          val constants = domains.map { d =>
            val prefixed = if (d.nonEmpty && d.charAt(0).isDigit) "_" + d else d
            val safe = prefixed
              .replaceAll("[^A-Za-z0-9_]", "_")
              .replaceAll("_+", "_")
              .stripSuffix("_")
            "  final val " + safe + ": String = \"" + d + "\""
          }.mkString("\n")

          val code =
            """|// AUTO-GENERATED FILE. DO NOT EDIT DIRECTLY.
               |// Generated by DomainKeysGeneratorPlugin from: %s
               |package %s
               |
               |/**
               | * Distinct domain values extracted from config.json (configItems[].domainKeys[].domain)
               | * Total domains: %d
               | */
               |object %s {
               |%s
               |}
               |""".stripMargin.format(file.getName, pkg, domains.size, objectName, constants)

          outDir.mkdirs()
          val outFile = outDir / (objectName + ".scala")
          IO.write(outFile, code)
          log.info("[DomainKeysGenerator] Generated " + outFile.getAbsolutePath + s" (${domains.size} domain constants)")
          Seq(outFile)
        }
      }
    }
  )
}

